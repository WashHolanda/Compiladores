int processA; 
int processB;
int flagFinishA;
int flagFinishB;
int currentProcess;

int auxPosition;
int countTopStack;

int endProcess(void){    
    storePC();
    
    countTopStack = 0;
    auxPosition = (currentProcess*300)+10;

    storeRegs(auxPosition);

    while(countTopStack <= 9){
        storeStack((currentProcess*300)+countTopStack);
        countTopStack = countTopStack + 1;
    }
    countTopStack = 10;

    if(currentProcess == 3){
        currentProcess = 2;
        flagFinishB = 1;
        if(flagFinishA == 1){
            return 0;
        }
    }
    if(currentProcess == 2){
        currentProcess = 3;
        flagFinishA = 1;
        if(flagFinishB == 1){
            return 0;
        }
    }
    
    auxPosition = (currentProcess*300)+10;

    while(countTopStack > 0){
        loadStack((currentProcess*300)+(countTopStack-1));
        countTopStack = countTopStack - 1;
    }

    loadRegs(auxPosition);
}

void switch(void){    
    storePC();
    
    countTopStack = 0;
    auxPosition = (currentProcess*300)+10;

    storeRegs(auxPosition);

    while(countTopStack <= 9){
        storeStack((currentProcess*300)+countTopStack);
        countTopStack = countTopStack + 1;
    }
    countTopStack = 10;

    if(currentProcess == 2){
        currentProcess = 3;
    }
    else{
        currentProcess = 2;
    }
    auxPosition = (currentProcess*300)+10;

    while(countTopStack > 0){
        loadStack((currentProcess*300)+(countTopStack-1));
        countTopStack = countTopStack - 1;
    }

    loadRegs(auxPosition);
}

void main (void){
    processA = 2;
    processB = 3;
    flagFinishA = 0;
    flagFinishB = 0;

    loadStack(((processA)+(processB*300)));

    currentProcess = processA;
    loadStack((currentProcess*300));
}